
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>User guide &#8212; Cirq on IQM 3.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Reference" href="API.html" />
    <link rel="prev" title="Cirq on IQM" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="API.html" title="API Reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Cirq on IQM"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Cirq on IQM 3.5 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">User guide</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="user-guide">
<span id="id1"></span><h1>User guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h1>
<p>This guide serves as an introduction to the main features of Cirq on IQM. You are encouraged to run the demonstrated
code snippets and check the output yourself.</p>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>The recommended way is to install the distribution package <code class="docutils literal notranslate"><span class="pre">cirq-iqm</span></code> directly from the Python Package Index (PyPI):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ pip install cirq-iqm
</pre></div>
</div>
<p>After installation Cirq on IQM can be imported in your Python code as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq_iqm</span>
</pre></div>
</div>
</section>
<section id="iqm-s-quantum-devices">
<h2>IQM’s quantum devices<a class="headerlink" href="#iqm-s-quantum-devices" title="Permalink to this headline">¶</a></h2>
<p>Cirq on IQM provides descriptions of IQM’s quantum architectures as subclasses of <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice" title="cirq_iqm.devices.iqm_device.IQMDevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">IQMDevice</span></code></a>.
The abstract class <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice" title="cirq_iqm.devices.iqm_device.IQMDevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">IQMDevice</span></code></a> itself is a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.devices.Device</span></code> and implements general
functionality relevant to all IQM devices. Each device subclass describes the native gates and the connectivity of a particular architecture
and the relevant functionality. As an example, let us import the class <a class="reference internal" href="api/cirq_iqm.devices.adonis.Adonis.html#cirq_iqm.devices.adonis.Adonis" title="cirq_iqm.devices.adonis.Adonis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Adonis</span></code></a>, which describes IQM’s
five-qubit architecture and view some of its properties contained in the class variables:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cirq_iqm</span> <span class="kn">import</span> <span class="n">Adonis</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Adonis</span><span class="o">.</span><span class="n">QUBIT_COUNT</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Adonis</span><span class="o">.</span><span class="n">NATIVE_GATES</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Adonis</span><span class="o">.</span><span class="n">CONNECTIVITY</span><span class="p">)</span>
</pre></div>
</div>
<p>IQM devices use <code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.NamedQubit</span></code> to represent their qubits. The names of the qubits consist of a prefix
followed by a numeric index, so we have qubit names like <code class="docutils literal notranslate"><span class="pre">QB1</span></code>, <code class="docutils literal notranslate"><span class="pre">QB2</span></code>, etc. Note that we use 1-based
indexing. The qubit connectivity information is stored using the qubit indices only. You can get the list of the qubits
in a particular device by accessing the <code class="docutils literal notranslate"><span class="pre">qubits</span></code> attribute of a corresponding <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice" title="cirq_iqm.devices.iqm_device.IQMDevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">IQMDevice</span></code></a> instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adonis</span> <span class="o">=</span> <span class="n">Adonis</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">adonis</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="constructing-circuits">
<h2>Constructing circuits<a class="headerlink" href="#constructing-circuits" title="Permalink to this headline">¶</a></h2>
<p>There are three main workflows of using <code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.Circuit</span></code> instances with IQM devices:</p>
<ol class="arabic simple">
<li><p>Create a <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> instance associated with an <code class="docutils literal notranslate"><span class="pre">IQMDevice</span></code>, and use only the device qubits.
Each <code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.Operation</span></code> is validated (i.e. checked that qubits are on the device, and properly connected) and
decomposed into native operations as soon as it is appended to the circuit.</p></li>
<li><p>Create a <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> instance with no associated device, use arbitrary qubit names and types. There is no
validation of the operations when appended. At any point the user can apply <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice.decompose_circuit" title="cirq_iqm.devices.iqm_device.IQMDevice.decompose_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IQMDevice.decompose_circuit()</span></code></a>
to decompose the circuit contents into the native operation set of the device, or <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice.route_circuit" title="cirq_iqm.devices.iqm_device.IQMDevice.route_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IQMDevice.route_circuit()</span></code></a>
to route the circuit to the device connectivity and device qubits.</p></li>
<li><p>Create a <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> from an OpenQASM 2.0 program. The qubit names are determined by the OpenQASM <code class="docutils literal notranslate"><span class="pre">qreg</span></code> names,
appended with zero-based indices. Proceed as in workflow 2.</p></li>
</ol>
<p>Below we demonstrate examples of creating circuits in each of the three workflows.</p>
<section id="workflow-1">
<h3>Workflow 1<a class="headerlink" href="#workflow-1" title="Permalink to this headline">¶</a></h3>
<p>Construct a circuit associated with the Adonis architecture. You have to use the qubits of the corresponding
device and respect the connectivity of the device when appending gates to the circuit.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq</span>
<span class="kn">from</span> <span class="nn">cirq_iqm</span> <span class="kn">import</span> <span class="n">Adonis</span>

<span class="n">adonis</span> <span class="o">=</span> <span class="n">Adonis</span><span class="p">()</span>
<span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">adonis</span><span class="o">.</span><span class="n">qubits</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">circuit_1</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">adonis</span><span class="p">)</span>
<span class="n">circuit_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
<span class="n">circuit_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">q3</span><span class="p">))</span>
<span class="n">circuit_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q3</span><span class="p">))</span>
<span class="n">circuit_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q3</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circuit_1</span><span class="p">)</span>
</pre></div>
</div>
<p>If you print the circuit at this point, you will see that instead of the gates we have appended, it
contains their decompositions in terms of the native gate set of the <code class="docutils literal notranslate"><span class="pre">Adonis</span></code> device.
This is because in this way of creating a circuit the gates are decomposed right away
when they are appended to the circuit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>QB1: ───X────────────────────@───────────M(&#39;m&#39;)───
                             │           │
QB3: ───Y^0.5───X───Y^-0.5───@───Y^0.5───M────────
</pre></div>
</div>
</section>
<section id="workflow-2">
<span id="id2"></span><h3>Workflow 2<a class="headerlink" href="#workflow-2" title="Permalink to this headline">¶</a></h3>
<p>Construct a circuit with no associated device and use arbitrary qubits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq</span>
<span class="kn">from</span> <span class="nn">cirq_iqm</span> <span class="kn">import</span> <span class="n">Adonis</span>

<span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">NamedQubit</span><span class="p">(</span><span class="s1">&#39;Alice&#39;</span><span class="p">),</span> <span class="n">cirq</span><span class="o">.</span><span class="n">NamedQubit</span><span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">)</span>
<span class="n">circuit_2</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="n">circuit_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
<span class="n">circuit_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">q2</span><span class="p">))</span>
<span class="n">circuit_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">))</span>
<span class="n">circuit_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circuit_2</span><span class="p">)</span>
</pre></div>
</div>
<p>This will result in the circuit</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Alice: ───X───@───M(&#39;m&#39;)───
              │   │
Bob: ─────H───X───M────────
</pre></div>
</div>
<p>After the circuit has been constructed, it can be decomposed and routed against a particular <code class="docutils literal notranslate"><span class="pre">IQMDevice</span></code>.
The method <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice.decompose_circuit" title="cirq_iqm.devices.iqm_device.IQMDevice.decompose_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IQMDevice.decompose_circuit()</span></code></a> accepts a <code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.Circuit</span></code> object as an argument and
returns the decomposed circuit containing only native gates for the corresponding device:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">decomposed_circuit_2</span> <span class="o">=</span> <span class="n">adonis</span><span class="o">.</span><span class="n">decompose_circuit</span><span class="p">(</span><span class="n">circuit_2</span><span class="p">)</span>
</pre></div>
</div>
<p>The method <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice.route_circuit" title="cirq_iqm.devices.iqm_device.IQMDevice.route_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IQMDevice.route_circuit()</span></code></a> accepts a <code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.Circuit</span></code> object as an argument,
and returns the circuit routed against the device, acting on the device qubits instead of the
arbitrary qubits we had originally.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">routed_circuit_2</span> <span class="o">=</span> <span class="n">adonis</span><span class="o">.</span><span class="n">route_circuit</span><span class="p">(</span><span class="n">decomposed_circuit_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">routed_circuit_2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>QB3: ───X────────────────────@───────────M(&#39;m&#39;)───
                             │           │
QB4: ───Y^0.5───X───Y^-0.5───@───Y^0.5───M────────
</pre></div>
</div>
<p>By default <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice.route_circuit" title="cirq_iqm.devices.iqm_device.IQMDevice.route_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">route_circuit()</span></code></a> returns only the routed circuit. However if you set its keyword
argument <code class="docutils literal notranslate"><span class="pre">return_swap_network</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>, it will return the full
<code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.contrib.routing.swap_network.SwapNetwork</span></code> object which contains the routed
circuit itself and the mapping between the used device qubits and the original ones.</p>
<p>Under the hood, <a class="reference internal" href="api/cirq_iqm.devices.iqm_device.IQMDevice.html#cirq_iqm.devices.iqm_device.IQMDevice.route_circuit" title="cirq_iqm.devices.iqm_device.IQMDevice.route_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">route_circuit()</span></code></a> leverages the routing algorithm in <code class="xref py py-mod docutils literal notranslate"><span class="pre">cirq.contrib.routing.router</span></code>.
It works on single- and two-qubit gates, and measurement operations of arbitrary size.
If you have gates involving more than two qubits you need to decompose them before routing.
Since routing may add some SWAP gates to the circuit, you will need to decompose the circuit
again after the routing, unless SWAP is a native gate for the target device.</p>
<p>Yet another important topic is circuit optimization. In addition to the optimizers available in Cirq you can also
benefit from Cirq on IQM’s <a class="reference internal" href="api/cirq_iqm.optimizers.html#module-cirq_iqm.optimizers" title="cirq_iqm.optimizers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">optimizers</span></code></a> module which contains some optimization tools geared towards IQM devices.
The function <a class="reference internal" href="api/cirq_iqm.optimizers.simplify_circuit.html#cirq_iqm.optimizers.simplify_circuit" title="cirq_iqm.optimizers.simplify_circuit"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimizers.simplify_circuit()</span></code></a> is a convenience method encapsulating a particular sequence of
optimizations. Let us try it out on our decomposed and routed circuit above:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cirq_iqm.optimizers</span> <span class="kn">import</span> <span class="n">simplify_circuit</span>

<span class="n">simplified_circuit_2</span> <span class="o">=</span> <span class="n">simplify_circuit</span><span class="p">(</span><span class="n">routed_circuit_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">simplified_circuit_2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>QB3: ───PhX(1)───@───────────────────M(&#39;m&#39;)───
                 │                   │
QB5: ────────────@───PhX(-0.5)^0.5───M────────
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The funtion <a class="reference internal" href="api/cirq_iqm.optimizers.simplify_circuit.html#cirq_iqm.optimizers.simplify_circuit" title="cirq_iqm.optimizers.simplify_circuit"><code class="xref py py-func docutils literal notranslate"><span class="pre">simplify_circuit()</span></code></a> is not associated with any IQM device, so its result may contain non-native
gates for a particular device. In the example above we don’t have them, however it is generally a good idea to run
decomposition once again after the simplification.</p>
</div>
</section>
<section id="workflow-3">
<h3>Workflow 3<a class="headerlink" href="#workflow-3" title="Permalink to this headline">¶</a></h3>
<p>You can read an OpenQASM 2.0 program from a file (or a string), e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPENQASM</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="n">include</span> <span class="s2">&quot;qelib1.inc&quot;</span><span class="p">;</span>

<span class="n">qreg</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">creg</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="n">x</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">h</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">cx</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">measure</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="p">;</span>
</pre></div>
</div>
<p>and convert it into a <code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.Circuit</span></code> object using <a class="reference internal" href="api/cirq_iqm.extended_qasm_parser.circuit_from_qasm.html#cirq_iqm.extended_qasm_parser.circuit_from_qasm" title="cirq_iqm.extended_qasm_parser.circuit_from_qasm"><code class="xref py py-func docutils literal notranslate"><span class="pre">circuit_from_qasm()</span></code></a>.
Once you have done this, you can perform the decomposition and routing steps as in
the previous workflow to prepare the circuit for execution on an IQM device.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq_iqm</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;circuit.qasm&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">circuit_3</span> <span class="o">=</span> <span class="n">cirq_iqm</span><span class="o">.</span><span class="n">circuit_from_qasm</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circuit_3</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>q_0: ───X───@───M(&#39;m_0&#39;)───
            │
q_1: ───H───X───M(&#39;m_1&#39;)───
</pre></div>
</div>
<p><a class="reference internal" href="api/cirq_iqm.extended_qasm_parser.circuit_from_qasm.html#cirq_iqm.extended_qasm_parser.circuit_from_qasm" title="cirq_iqm.extended_qasm_parser.circuit_from_qasm"><code class="xref py py-func docutils literal notranslate"><span class="pre">circuit_from_qasm()</span></code></a> uses the OpenQASM 2.0 parser in <code class="xref py py-mod docutils literal notranslate"><span class="pre">cirq.contrib.qasm_import</span></code>.</p>
</section>
</section>
<section id="running-on-a-real-quantum-computer">
<h2>Running on a real quantum computer<a class="headerlink" href="#running-on-a-real-quantum-computer" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At the moment IQM does not provide a quantum computing service open to the general public.
Please contact our <a class="reference external" href="https://www.meetiqm.com/contact/">sales team</a> to set up your access to an IQM quantum computer.</p>
</div>
<p>Cirq contains various simulators which you can use to simulate the circuits constructed above.
In this subsection we demonstrate how to run them on an IQM quantum computer.</p>
<p>Cirq on IQM implements <a class="reference internal" href="api/cirq_iqm.iqm_sampler.IQMSampler.html#cirq_iqm.iqm_sampler.IQMSampler" title="cirq_iqm.iqm_sampler.IQMSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">IQMSampler</span></code></a>, a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">cirq.work.Sampler</span></code>, which is used
to execute quantum circuits. You need to have access to an IQM server and have a settings file for
the quantum hardware of interest. Once these resources are in place, you can create an
<a class="reference internal" href="api/cirq_iqm.iqm_sampler.IQMSampler.html#cirq_iqm.iqm_sampler.IQMSampler" title="cirq_iqm.iqm_sampler.IQMSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">IQMSampler</span></code></a> instance and use its <code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code> method to send a circuit for execution
and retrieve the results:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cirq_iqm.iqm_sampler</span> <span class="kn">import</span> <span class="n">IQMSampler</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">iqm_settings_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">sampler</span> <span class="o">=</span> <span class="n">IQMSampler</span><span class="p">(</span><span class="n">iqm_server_url</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">adonis</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circuit_1</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that the code snippet above assumes that you have set the variables <code class="docutils literal notranslate"><span class="pre">iqm_server_url</span></code> and
<code class="docutils literal notranslate"><span class="pre">iqm_settings_path</span></code>. If the IQM server you are connecting to requires authentication, you will also have to set
the IQM_SERVER_USERNAME and IQM_SERVER_API_KEY environment variables.</p>
<p>When executing a circuit that uses something other than the device qubits, you need to either route it first
as explained in <a class="reference internal" href="#workflow-2"><span class="std std-ref">workflow 2</span></a> above,
or provide the mapping from the <em>logical</em> qubits in the circuit to the <em>physical</em> qubits on the device yourself.
The initializer of <a class="reference internal" href="api/cirq_iqm.iqm_sampler.IQMSampler.html#cirq_iqm.iqm_sampler.IQMSampler" title="cirq_iqm.iqm_sampler.IQMSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">IQMSampler</span></code></a> accepts an optional argument called <code class="docutils literal notranslate"><span class="pre">qubit_mapping</span></code> which
can be used to specify this correspondence.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qubit_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Alice&#39;</span><span class="p">:</span> <span class="s1">&#39;QB1&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">:</span> <span class="s1">&#39;QB3&#39;</span><span class="p">}</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">iqm_settings_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">sampler</span> <span class="o">=</span> <span class="n">IQMSampler</span><span class="p">(</span><span class="n">iqm_server_url</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">adonis</span><span class="p">,</span> <span class="n">qubit_mapping</span><span class="o">=</span><span class="n">qubit_mapping</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">decomposed_circuit_2</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>If you have a circuit which already uses the device qubits, you don’t need to specify
the qubit mapping (as we did above for <code class="docutils literal notranslate"><span class="pre">circuit_1</span></code>).</p>
</section>
<section id="more-examples">
<h2>More examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h2>
<p>More examples are available in the
<a class="reference external" href="https://github.com/iqm-finland/cirq-on-iqm/tree/main/examples">examples directory</a>
of the Cirq on IQM repository.</p>
</section>
<section id="how-to-develop-and-contribute">
<h2>How to develop and contribute<a class="headerlink" href="#how-to-develop-and-contribute" title="Permalink to this headline">¶</a></h2>
<p>Cirq on IQM is an open source Python project.
You can contribute by creating GitHub issues to report bugs or request new features,
or by opening a pull request to submit your own improvements to the codebase.</p>
<p>To start developing the project, clone the
<a class="reference external" href="https://github.com/iqm-finland/cirq-on-iqm">GitHub repository</a>
and install it in editable mode with all the extras:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ git clone git@github.com:iqm-finland/cirq-on-iqm.git
$ <span class="nb">cd</span> cirq-on-iqm
$ pip install -e <span class="s2">&quot;.[dev,docs,testing]&quot;</span>
</pre></div>
</div>
<p>Build and view the docs:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tox -e docs
$ firefox build/sphinx/html/index.html
</pre></div>
</div>
<p>Run the tests:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tox
</pre></div>
</div>
</section>
<section id="tagging-and-releasing">
<h2>Tagging and releasing<a class="headerlink" href="#tagging-and-releasing" title="Permalink to this headline">¶</a></h2>
<p>After implementing changes to Cirq on IQM one usually wants to release a new version. This means
that after the changes are merged to the main branch -</p>
<ol class="arabic simple">
<li><p>the repository should have an updated CHANGELOG with information about the new changes,</p></li>
<li><p>the latest commit should be tagged with the new version number,</p></li>
<li><p>and a release should be created based on that tag.</p></li>
</ol>
<p>The last two steps are automated, so one needs to worry only about properly updating the CHANGELOG.
It should be done along with the pull request which is introducing the main changes. The new version
must be added on top of all existing versions and the title must be “Version MAJOR.MINOR”, where MAJOR.MINOR
represents the new version number. Please take a look at already existing versions and format the rest of
your new CHANGELOG section similarly. Once the pull request is merged into main, a new tag and a release will
be created automatically based on the latest version definition in the CHANGELOG.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">User guide</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#iqm-s-quantum-devices">IQM’s quantum devices</a></li>
<li><a class="reference internal" href="#constructing-circuits">Constructing circuits</a><ul>
<li><a class="reference internal" href="#workflow-1">Workflow 1</a></li>
<li><a class="reference internal" href="#workflow-2">Workflow 2</a></li>
<li><a class="reference internal" href="#workflow-3">Workflow 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-on-a-real-quantum-computer">Running on a real quantum computer</a></li>
<li><a class="reference internal" href="#more-examples">More examples</a></li>
<li><a class="reference internal" href="#how-to-develop-and-contribute">How to develop and contribute</a></li>
<li><a class="reference internal" href="#tagging-and-releasing">Tagging and releasing</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Cirq on IQM</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="API.html"
                        title="next chapter">API Reference</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/user_guide.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="API.html" title="API Reference"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Cirq on IQM"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Cirq on IQM 3.5 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">User guide</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020–2021, Cirq on IQM developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>